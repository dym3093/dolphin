
技术要点：
* synchronized 对象监视器为 Object 时的使用
* synchronized 对象监视器为 Class 时的使用
* 非线程安全是如何出现的
* 关键字 volatile 的主要作用
* volatile 与 synchronized 的区别和使用情况

1. “非线程安全”的问题存在于"实例变量"中，如果是方法内部的私有变量，则不存在线程安全的问题;
换句话说：实例变量会有非线程安全的隐患，而方法内部的私有变量是永远是线程安全的,是由内部变量的
私有特性决定。

2. synchronized 取得的锁都是对象锁
1) 多个线程访问一个对象时，JVM只创建一个对象锁，并且只会有一个对象取得该对象锁，其他线程则
   处于等待状态。
2) 多个线程访问多个对象，则JVM会创建多个对象锁。

[注意]
    1）调用 synchronized声明的方法一定是顺序运行的
    2）牢记“共享”二字，只有共享资源的读写才需要同步化，如果没有共享资源则没有同步的必要

3. synchronized 锁重入
synchronized 具有锁重入的功能，也就是在使用synchronized 时，当一个线程得到一个对象锁后，
再次请求此对象锁时可以再次得到该锁。
证明： synchronized方法/内部块调用本类的其他synchronized方法/块时，是永远得到锁的。

“可重入锁”的概念：自己可以再次获取自己的内部锁。比如一条线程获取了某个对象锁，此时线程还没有
释放锁，当再次请求这个对象锁的时候还是可以再次获取，如果锁不可重入，就会造成死锁。

可重入锁也支持在父子类的继承环境中,子类完全可以通过“可重入锁”调用父类的同步方法。

4. 出现异常，锁自动释放
    当一个线程执行的代码出现异常，其所持有的锁会自动释放。

5. 同步不具有继承性

6. 用同步代码块减少同步的范围，比同步方法效率高
eg. 同步代码块
synchronized (this){
    ...
}

使用同步代码块 synchronized(this)时需要注意：
    1)当一个线程访问Object的一个synchronized(this)同步代码块时，其他线程对同一个Object
    中所有其他 synchronized(this) 同步代码块将被阻塞， 这说明 synchronized(this)
    使用的“对象监视器”是一个。
    2) synchronized(this)代码块和synchronized修饰在方法上都是使用同一个“对象监视器” ，
    它们的[作用是等价的]， synchronized(this)代码块更为灵活

[总结]
    多个线程调用同一个对象中的不同synchronized同步方法或者同步代码块时，调用的效果是按顺序执行的，
    也就是同步，阻塞的。
    说明 synchronized 同步方法 或者 synchronized(this) 同步代码块分别有两种作用：
    1) synchronized method
    (1) 对于其他 synchronized 同步方法或者 synchronized(this) 同步代码块调用呈阻塞状态
    (2) 同一时间只有一个线程可以执行 synchronized 同步方法中的代码
    2) synchronized block
    (1) 对于其他 synchronized 同步方法或者 synchronized(this) 同步代码块调用呈阻塞状态
    (2) 同一时间只有一个线程可以执行 synchronized(this) 同步代码块中的代码

上述规则对于 synchronized(非this对象) 同样适用， 参考 part02 > MyService

synchronized(非this对象) 的好处：
    如果在一个类中有很多 synchronized 方法，这时虽然能实现同步，但会受到阻塞，所以影响效率，
    但如果使用 synchronized(非this对象) ，代码块中的程序与同步方法是异步的，不与其他
    synchronized(this) 争抢 this 锁，可以大大提高效率

[注意]
使用synchronized(非this对象)进行操作时，对象监视器必须是同一个对象，如果不是同一个对象，就无法
实现同步。

synchronized(非this对象)总结：
    1）当多个线程同时执行synchronized(x){}同步代码块时呈现同步效果;
    2）当其他线程执行x对象中的synchronized方法时呈现同步效果;
    3）当其他线程执行x对象中的synchronized同步代码块时呈现同步效果;
    但其他线程调用不加synchronized关键字的方法时，还是异步调用

7. synchronized加到static静态方法上是给 Class 类上锁， Class锁可以对类的所有对象实例起作用
   synchronized加到非静态方法上是给对象上锁

   同步synchronized(class)代码块的作用其实和 synchronized static 方法一样。
   在JVM中具有String常量池缓存的功能，将synchronized(string)同步块和String联合使用，需要注意
一些意外。因为两个String值相同时，两个线程持有相同的锁，所以造成其中一个线程无法运行，这就是String
线程池带来的问题，一般不建议用String作为锁对象。

8. 锁对象的改变
    在将任何数据类型作为同步锁时，需要注意是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，
    则这些线程就是同步的;如果分别获得锁对象，这线线程之间就是异步的。

[注意]
    只要对象不变，即使对象的属性发生变化，运行的结果还是同步。

9. volatile 关键字
   1) volatile 的作用是强制从公共堆栈（主内存）中取得变量的值加载到线程工作内存，而不是从
   线程私有数据栈(工作内存)中取得变量值，保证了工作内存中的数据值最新。
   2) volatile保证了实例变量在多线程中的可见性，但是最致命的缺点是不支持原子性。

10. synchronized 和 volatile 比较
    1) volatile是线程同步的轻量级实现，所以volatile的性能比synchronized的好，volatile只能
    修饰变量，而synchronized可以修饰方法，代码块;新的JDK发布，提高了synchronized的效率，
    开发中建议使用synchronized。
    2) 多线程访问volatile不会发生阻塞，而访问synchronized会产生阻塞。
    3) volatile保证数据的可见性，但是不保证数据的原子性;而synchronized二者均能保证，因为其会
    将私有内存和公共内存中的数据同步。
    4) volatile解决的是变量在多线程中的可见性;而synchronized解决的是多线程间访问资源的同步性。

[注意]
    线程安全包含原子性和可见性两个方面，Java的同步机制都是围绕这两个方面来确保线程安全的。

******************************** 相关知识 begin ********************************

[原子性（Atomicity）]
原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
如果一个操作时原子性的，那么多线程并发的情况下，就不会出现变量被修改的情况

比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。
再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。

非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。
一个操作是原子操作，那么我们称它具有原子性。Java的concurrent包下提供了一些原子类，我们可以通过
阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。

（由Java内存模型来直接保证的原子性变量操作包括read、load、use、assign、store和write六个，大致
可以认为基础数据类型的访问和读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存
模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机未把lock与unlock操作直接开放给用户使用，
但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐匿地使用这两个操作，这两个字节码
指令反映到Java代码中就是同步块—synchronized关键字，因此在synchronized块之间的操作也具备原子性。）

Java中的原子性，是指：原子操作是不能被线程调度机制中断的；操作一旦开始，它一定会在可能发生的“上下文
切换”（即切换到其他线程执行）之前执行完毕。
但是千万不要认为“原子操作不需要同步控制（这是错误的）”！

原子性可以应用于除long和double之外的基本类型的简单操作（赋值和返回值）。long和double这种64位的
数据类型，在JVM内部是通过两条32位的操作完成的，因此有可能发生上下文切换。如果给long和double变量
加上volatile关键字也可以获得原子性。

但是原子性并不能保证并发的代码的正确性。比如，在多处理器（可能是单处理器但是多核）多线程环境下，
一个线程对某一变量的写入操作有可能只是将这种变化存在了CPU缓存中，而其他线程对该变量的访问只是局限在
各自的CPU缓存，这样导致了不一致性。因此，还需要使用volatile关键字来保证可见性，将变量的修改直接
写入到内存中。

当然同步（加锁）机制也可以保证这种可见性，将变量的修改直接写到内存中。
在同一个任务中，可见性问题是不存在的。即该任务对变量的修改，该任务肯定知道。
但是，当一个属性的值依赖于它之前的值时（如递增操作），一个属性的值依赖于其他域的值的限制，
volatile就无法工作了。这里说的不能工作了，应该是指在并发环境下无法保证代码的正确性吧。

我的理解：原子性+volatitle可以保证并发的正确性。但是，最好编码时还是尽量用 同步加锁 来保证并发
的正确性。第一选择应该是synchronized关键字。

再次声明：在Java中，自增操作不是原子的。
在《Thinking in java》第四版中文版的682-684页举例详细说明下面两点：
（1）在java中，对除long和double之外的基本类型的简单操作（赋值、返回值）是原子性的，但是无法保证并发的正确性。
（2）在java中，递增操作不是原子性的，会引发并发问题。

[可见性(Visibility)]
可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java内存模型是通过在变量
修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的，
无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是volatile的特殊规则保证了
新值能立即同步到主内存，以及每使用前立即从内存刷新。因为我们可以说volatile保证了线程操作时变量的
可见性，而普通变量则不能保证这一点。

除了volatile之外，Java还有两个关键字能实现可见性，它们是synchronized。同步块的可见性是由
“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store和write操作)”这条规则获得的，
而final关键字的可见性是指：被final修饰的字段是构造器一旦初始化完成，并且构造器没有把“this”引用传
递出去，那么在其它线程中就能看见final字段的值。

（可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。
另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程
内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让
被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；
这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就这这个操作同样存在线程安全问题。）

******************************** 相关知识 end ********************************

11. 自增i++(减 i--)操作不是原子操作，其步骤分解如下：
    1) 从内存中取出i的值;
    2) 计算i的值;
    3) 将i的值写到内存中。

使用concurrent包中的原子类可以在没有锁的情况下保证线程安全; AtomicInteger.incrementAndGet()。












