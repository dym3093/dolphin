
1. “非线程安全”的问题存在于"实例变量"中，如果是方法内部的私有变量，则不存在线程安全的问题;
换句话说：实例变量会有非线程安全的隐患，而方法内部的私有变量是永远是线程安全的,是由内部变量的
私有特性决定。

2. synchronized 取得的锁都是对象锁
1) 多个线程访问一个对象时，JVM只创建一个对象锁，并且只会有一个对象取得该对象锁，其他线程则
   处于等待状态。
2) 多个线程访问多个对象，则JVM会创建多个对象锁。

[注意]
    1）调用 synchronized声明的方法一定是顺序运行的
    2）牢记“共享”二字，只有共享资源的读写才需要同步化，如果没有共享资源则没有同步的必要

3. synchronized 锁重入
synchronized 具有锁重入的功能，也就是在使用synchronized 时，当一个线程得到一个对象后，
再次请求此对象锁时可以再次得到该锁。
证明： synchronized方法/内部块调用本类的其他synchronized方法/块时，是永远得到锁的。

“可重入锁”的概念：自己可以再次获取自己的内部锁。比如一条线程获取了某个对象锁，此时线程还没有
释放锁，当再次请求这个对象锁的时候还是可以再次获取，如果锁不可重入，就会造成死锁。

可重入锁也支持在父子类的继承环境中,子类完全可以通过“可重入锁”调用父类的同步方法。

4. 出现异常，锁自动释放
    当一个线程执行的代码出现异常，其所持有的锁会自动释放。

5. 同步不具有继承性

6. 用同步代码块减少同步的范围，比同步方法效率高
eg. 同步代码块
synchronized (this){
    ...
}

使用同步代码块 synchronized(this)时需要注意：
    1)当一个线程访问Object的一个synchronized(this)同步代码块时，其他线程对同一个Object
    中所有其他 synchronized(this) 同步代码块将被阻塞， 这说明 synchronized(this)
    使用的“对象监视器”是一个。
    2) synchronized(this)代码块和synchronized修饰在方法上都是使用同一个“对象监视器” ，
    它们的[作用是等价的]， synchronized(this)代码块更为灵活

[总结]
    多个线程调用同一个对象中的不同synchronized同步方法或者同步代码块时，调用的效果是按顺序执行的，
    也就是同步，阻塞的。
    说明 synchronized 同步方法 或者 synchronized(this) 同步代码块分别有两种作用：
    1) synchronized method
    (1) 对于其他 synchronized 同步方法或者 synchronized(this) 同步代码块调用呈阻塞状态
    (2) 同一时间只有一个线程可以执行 synchronized 同步方法中的代码
    2) synchronized block
    (1) 对于其他 synchronized 同步方法或者 synchronized(this) 同步代码块调用呈阻塞状态
    (2) 同一时间只有一个线程可以执行 synchronized(this) 同步代码块中的代码

上述规则对于 synchronized(非this对象) 同样适用， 参考 part02 > MyService

synchronized(非this对象) 的好处：
    如果在一个类中有很多 synchronized 方法，这时虽然能实现同步，但会受到阻塞，所以影响效率，
    但如果使用 synchronized(非this对象) ，代码块中的程序与同步方法是异步的，不与其他
    synchronized(this) 争抢 this 锁，可以大大提高效率

[注意]
使用synchronized(非this对象)进行操作时，对象监视器必须是同一个对象，如果不是同一个对象，就无法
实现同步。

synchronized(非this对象)总结：
    1）当多个线程同时执行synchronized(x){}同步代码块时呈现同步效果;
    2）当其他线程执行x对象中的synchronized方法时呈现同步效果;
    3）当其他线程执行x对象中的synchronized同步代码块时呈现同步效果;
    但其他线程调用不加synchronized关键字的方法时，还是异步调用








