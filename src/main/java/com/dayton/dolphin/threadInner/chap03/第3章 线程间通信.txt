
技术要点：
* 使用 wait/notify 实现线程间的通信
* 生成者/消费者模式的实现
* 方法 join 的使用
* ThreadLocal 类的使用

1. 等待/通知机制的实现
wait()/notify()

    1)方法wait()的作用是使当前执行代码的线程进行等待， wait() 方法是 Object 类的方法，该方法用来
    将当前线程放入“预执行队列”中，并且在 wait() 所在的代码行处停止执行，直到接到通知或者被中断为止。
    在调用 wait() 方法之前，线程必须获得该对象的对象级别锁，即只能在同步方法或者同步代码块中调用wait()
    方法。
    在执行 wait() 方法后，当前线程释放锁。在 wait() 方法返回前,线程和其他线程竞争获取锁。如果调用
    wait() 时没有持有适当的锁，则抛出 IllegalMonitorStateException , 它是 RuntimeException
    的一个子类，因此不需要 try-catch 语句进行捕捉异常。

    2) 方法 notify() 也需要在 synchronized-method 或者 synchronized-block 中调用，在调用前
    线程也必须获取该对象的对象级别锁。 如果 notify() 没有持有适当的锁，则抛出
    IllegalMonitorStateException 。
    该方法用于通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规则器随机挑选其中
    一个呈 wait 状态的线程， 对其发出通知 notify ， 并使它等待获取该对象的对象锁。
    需要注意的是，在执行 notify() 后，当前线程不会马上释放该对象锁， wait 状态的线程也不会马上获取
    到该对象锁，要等待执行 notify() 方法的线程将程序执行完，也就是退出 synchronized-block 后，
    当前线程才会释放锁，而呈 wait 状态所在的线程才可以获取该对象锁。

[总结]
    wait 使线程停止运行， notify 使停止的线程继续运行。

2. 线程主要状态剖析

线程进入 Runnable 状态的5中状况：
    1)调用 sleep() 方法后经过的时间超过了指定的休眠时间;
    2)线程调用的阻塞 IO 已经返回，阻塞方法已经执行完毕；
    3)线程成功获得试图同步的监视器
    4)线程正在等待某个通知，其他线程发出了通知
    5)处于挂起状态的线程调用了 resume 恢复方法

出现阻塞的情况大体分为以下5种：
    1）线程调用 sleep() 方法，主动放弃占用的处理器资源;
    2）线程调用阻塞式 IO 方法，在该方法返回前，该线程处于阻塞状态;
    3）线程试图获得一个同步监视器，但该同步监视器正在被其他线程所持有;
    4）线程正在等待某个通知;
    5）程序调用了 suspend 方法将该线程挂起，此方法容易导致死锁，不建议采用。

[注意]
    每个锁都有两个队列，一个是就绪队列，一个是阻塞队列。
    就绪队列：存储将要获得锁的线程，一个线程被唤醒后就会进入就绪队列，等待CPU调度。
    阻塞队列：存储被阻塞线程，一个线程被 wait 后就会进行阻塞队列，等待下一次被唤醒。

3. wait/sleep

    wait() 自动释放锁（个人理解：wait等待，等待啥？因为没有锁，所以等待锁，因此肯定自动释放了锁），
    需要其他线程唤醒，如果超时未被唤醒，则抛出异常; 如果wait()不带时间限制，会一直等待。
    wait()后进入该对象相关的等待队列中,因此需要抛开所有？？？

    sleep() 让出CPU资源，但不会释放(不让出)锁（个人理解：只是休息一会，手里的东西还是拽着，休息时间到后
    ，该干嘛还是干嘛）,时间到后进入就绪状态。必须捕获异常。




























